<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>array</title>
</head>
<body>
    <script>
        // 리터럴 : 할당되기 전의 값
        // {} : 객체의 리터럴
        // [] : 배열의 리터럴
        // "hello" 문자열의 리터럴
        // 1234 숫자의 리터럴
        let myObj = {
            val1 : 10,
            val2 : 30
        }
        
        let myarray = []; // 많이 사용
        let myArray = new Array(5); // 이렇게 잘 안씀
        let myArray2 = new Array(4,3,2);
        console.log(myArray);
        console.log(myArray2);
        console.log(myArray2[0]);

        // unshift() : 맨 앞에서 요소를 추가할 때 <-> push()
        const cafe = ['coffee', 'cake', 'tea', 'cookie']
        const count = cafe.unshift('bread');
        console.log(count);
        console.log(cafe);

        // shift() : 맨 앞에서 요소를 지울 때 <-> pop()
        const cafe2 = ['coffee', 'cake', 'tea', 'cookie']
        const firstElement = cafe2.shift();
        console.log(firstElement);
        console.log(cafe2);

        // splice()
        // 배열.splice(요소를 위치시키고자 하는 인덱스, 제거할 요소의 개수)
        const cafe3 = ['coffee', 'cake', 'tea', 'cookie']
        cafe3.splice(-2, 1, 'scone'); // 배열의 끝에서부터
        console.log(cafe3);

        // slice() : 배열 일부분을 잘라내서 새로운 배열로 반환할 때
        const cafe4 = ['coffee', 'cake', 'tea', 'cookie']

        cafe4.slice(1, 3);
        //expected output: ['cake', 'tea']

        cafe4.slice(2);
        //expected output: ['tea', 'cookie']

        cafe4.slice(-2, -1);
        //expected output: ['tea']

        cafe4.slice(0, -2);
        //expected output: ['coffee', 'cake']

        // 문제
        // 다음 배열에서 물고기가 아닌 것을 slice로 선택해 콘솔로 출력해 보세요.
        let fish = ['정어리', '고등어', '돌고래', '참치', '고래상어', '코끼리'];
        console.log(fish.slice(2, 3));
        console.log(fish.slice(-1));
        console.log(fish.slice(5));

        // reverse() : 순서를 거꾸로 뒤집고 싶을 때. 원본 배열을 변형시킴
        const cafe5 = ['coffee', 'cake', 'tea', 'cookie'];
        console.log(cafe5.reverse());


        // indexOf() : 요소의 인덱스를 찾고 싶을 때
        const cafe6 = ['tea', 'coffee', 'cake', 'tea', 'cookie', 'tea']
        console.log(cafe6.indexOf('tea')); // 같은 단어가 여러 개 있을 때 앞에서 부터 찾고 찾으면 종료
        console.log(cafe6.indexOf('coffe', 1));
        console.log(cafe6.indexOf('bread'));

        // join() : 요소들을 연결해 하나의 값으로 만들 때
        const cafe7 = ['coffee', 'cake', 'tea', 'cookie']
        console.log(cafe7.join('/'));
        //expected output: 'coffee/cake/tea/cookie'
        console.log(cafe7.join(''));
        //expected output: 'coffeecaketeacookie'
        const example = ['coffee', null, undefined, 'cake']
        console.log(example.join(''));
        //expected output: 'coffeecake'

        console.log(cafe7.join('/').split('/')); // 메소드 체이닝 : 메소드와 메소드가 연결되어 있다는 뜻 -> 반환 값이 메소드를 가지고 있어서
        
        // includes() : 특정 요소가 포함되었는지 확인할 때
        const cafe8 = ['coffee', 'cake', 'tea', 'cookie']
        console.log(cafe8.includes('bread'));
        //expected output: false
        console.log(cafe8.includes('cake'));
        //expected output: true
        console.log(cafe8.includes('cake', -3));
        //expected output: true
        console.log(cafe8.includes('cake', 3));

        // find() : 하나의 요소라도 조건을 만족하는지 확인할 때
        const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        console.log(arr.find(i => i > 5)); // i안에 요소들이 하나씩 들어가서 쭉 훑어보다가 'i > 5' 이 조건식이 만족하는 값을 출력
        //expected output: 6

        // filter() : 모든 요소가 조건을 만족하는지 확인할 때
        const arr2 = [{
            'name' : 'title1',
            'contents' : 'contents1',
            'dataNum' : 1
        }, {
            'name' : 'title2',
            'contents' : 'contents2',
            'dataNum' : 2
        }, {
            'name' : 'title3',
            'contents' : 'contents3',
            'dataNum' : 3
        }, {
            'name' : 'title4',
            'contents' : 'contents4',
            'dataNum' : 4
        }, {
            'name' : 'title5',
            'contents' : 'contents5',
            'dataNum' : 5
        }];

        console.log(arr2.filter(i => i.dataNum > 3));
        //expected output:
        // [{
        //     'name' : 'title4',
        //     'contents' : 'contents4',
        //     'dataNum' : 4
        // }, {
        //     'name' : 'title5',
        //     'contents' : 'contents5',
        //     'dataNum' : 5
        // }]

        // map() : 각각 요소에 함수를 호출할 때
        const arr3 = [{
            'name' : 'title1',
            'contents' : 'contents1',
            'dataNum' : 1,
            'data' : [1, 2, 3]
        }, {
            'name' : 'title2',
            'contents' : 'contents2',
            'dataNum' : 2,
            'data' : [1, 2, 3]
        }, {
            'name' : 'title3',
            'contents' : 'contents3',
            'dataNum' : 3,
            'data' : [1, 2, 100]
        }, {
            'name' : 'title4',
            'contents' : 'contents4',
            'dataNum' : 4,
            'data' : [1, 2, 3]
        }, {
            'name' : 'title5',
            'contents' : 'contents5',
            'dataNum' : 5,
            'data' : [1, 2, 100]
        }];


        console.log(arr3.map(i => i.name));
        //expected output: ['title1', 'title2', 'title3', 'title4', 'title5']
        const newArray = arr3.map(function(i) {
            return i.name;
        });
        console.log(newArray);

        console.log(arr3.map(i => i.name).indexOf('title3'));
        //expected output: 2

        // 문제
        // map메소드를 이용해서 name의 값들을 원소로 하는 새로운 배열을 만들어 봅시다.
        var studentList = [
            {
                id: 1, name: '원범', score: 'great'
            },
            {
                id: 2, name: '김진', score: 'nice'
            },
            {
                id: 3, name: '혜원', score: 'good'
            },
            {
                id: 4, name: '재현', score: 'too cool for school'
            }
        ];
        let newStudentName = studentList.map(i => i.name);
        console.log(newStudentName);
        let newStdentName2 = studentList.map(function(i){
            return i.name;
        });
        console.log(newStdentName2);
        // filter 와 map 의 차이
        // 필터는 조건식에 맞는 요소들만 뽑아서 배열화하여 반환
        // 맵은 전부 훑어서 뽑아내기도 하고, 가공해서 배열로 만들어 반환하기도 함.
        // 맵 안에서 조건문을 쓸 바에는 필터를 사용하는 게 낫다.
        // 메서드의 목적 자체가 다르다.

        // forEach() : 각각의 요소를 실행하고 싶을 때
        const arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        arr4.forEach(i => console.log(i));
        // expected output: 1
        // expected output: 2
        // expected output: 3
        // expected output: 4
        // expected output: 5
        // expected output: 6
        // expected output: 7
        // expected output: 8
        // expected output: 9
        // expected output: 10
        // 원소의 개수만큼 실행. 배열 안의 요소를 순환하는 메소드다.

        // 비슷한 메소드가 생긴 이유?
        // foreach는 훨씬 이전에 만들어진 메소드다. 함수 안에 있는 값을 실행시킬 때 주로 사용. 배열 반환이 필요 없을 때! ex) 벤딩머신 음료 클릭했을 때 배열 반환보단 요소 반환으로 선택한 음료 목록을 출력할 때..
        // map은 상대적으로 최근에 등장함.
        // 필요에 따라 사용하기

        // concat() : 배열을 합치거나 새로운 요소를 추가할 때 (여라가지 요소를 한번에 추가하는 것이 가능)
        const cafe9 = ['coffee'];

        console.log(cafe9.concat(['cake']));
        //expected output: ['coffee', 'cake']

        console.log(cafe9.concat(['tea'], 'cookie'));
        //expected output: ['coffee', 'tea', 'cookie']

        // sort() : 배열 내 요소를 정렬할 때 -> 원소를 문자열로 바꿔서 정렬함
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort 
        const arr10 = [3, 4, 1, 2]
        console.log(arr10);
        console.log(arr10.sort());
        console.log(arr10);
        //expected output: [1, 2, 3, 4]

        const vegetable = ['beet', 'carrot', 'apple']
        console.log(vegetable.sort());
        //expected output: ['apple', 'beet', 'carrot']

        const numbers = [400, 200, 100];
        console.log(numbers);
        console.log(numbers.sort());
        const numbers2 = [40, 200, 10000];
        console.log(numbers2.sort()); // 10000 200 40 -> 첫 글자의 스트링으로 비교...(유니코드상에서 비교)

        // 숫자 크기로 정렬하기
        const arrNum = [13, 9, 10, 2];
        console.log(arrNum);
        arrNum.sort(function(a, b) {
            console.log(a, b);
            return a - b;
        });
        // 9 - 13 => 음수 : 두 개의 위치를 바꿈 [9, 13, 10, 2]
        // 10 - 9 => 양수 : 위치 바꾸지 않음 [9, 13, 10, 2]
        // 10 - 13 => [9, 10, 13, 2]
        // 10 - 9 => [9, 10, 13, 2]
        // 2 - 10 => [9, 2, 10, 13]
        // 2 - 9 => [2, 9, 10, 13]
        console.log(arrNum);

        console.log('-------');
        const arrNum2 = [13, 10, 8, 9];
        console.log(arrNum2);
        arrNum2.sort(function(a, b) {
            console.log(a, b);
            return a - b;
        });
        console.log(arrNum2);

        const itemList = [
            {id: 1, product: '연필', stock: 10},
            {id: 2, product: '노트', stock: 100},
            {id: 3, product: '지우개', stock: 5},
            {id: 4, product: '볼펜', stock: 30},
        ]
        itemList.sort(function(a, b){
            return a.stock - b.stock;
        });
        console.log(itemList);
        

    </script>
</body>
</html>